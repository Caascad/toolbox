#!/usr/bin/env bash
# shellcheck disable=SC1117

set -e
set -o pipefail

NIX_INSTALL_URL="${NIX_INSTALL_URL:-https://nixos.org/nix/install}"
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
ENTRYPOINT=$DIR/default.nix
BASH_COMPL_SCRIPT=$DIR/scripts/toolbox.complete.bash.sh

log() {
    local args="$*"
    local PLEASE="\e[32m[toolbox]:\e[0m"
    echo -e "$PLEASE $args"
}

log-error() {
    local args="$*"
    local PLEASE="\e[31m[toolbox]\e[0m"
    echo -e "$PLEASE $args"
}

log-run() {
    local cmd="$1"
    log "Running \"$cmd\"\n"
    eval $cmd
}


_get_name() {
    local pkg="$1"
    nix-instantiate --strict --eval --expr "(import $ENTRYPOINT {}).$1.name" | tr -d '"'
}

#
# sanity check functions
#

_isRegularUser() {
    test $(id -u) -ne 0
}

_hasKvmSupport() {
    test -c /dev/kvm && test -w /dev/kvm && test -r /dev/kvm
}

_isNixInstalled() {
    nix --version >/dev/null 2>&1
}

_sourceNix() {
    NIX_SH="$HOME/.nix-profile/etc/profile.d/nix.sh"
    test -f "$NIX_SH" && source "$NIX_SH" || true
}

_isSubstituterConfigured() {
    nix show-config | grep "toolbox.cachix.org" >/dev/null
}

_addCacheConfig() {
    if test -f ~/.config/nix/nix.conf
    then
        log "$HOME/.config/nix/nix.conf exists. Please follow the instructions from the README"
    else
        mkdir -p "$HOME"/.config/nix/
        cat << EOF > "$HOME"/.config/nix/nix.conf
substituters = https://cache.nixos.org https://toolbox.cachix.org
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= toolbox.cachix.org-1:ZFzO+86jD4G5ukgmLOnQRxjVmMcqu+60JTusH6pv8/8=
EOF
    fi
}

check_args() {
    local actual="$1"
    local expected="$2"
    local cmd="$3"

    if [ "$actual" -ne "$expected" ]; then
        log-error "'$cmd' requires $expected arguments but $actual were given"
        exit 1
    fi
}

#
# subcommands
#

register-completions() {
    cat <<EOF
ENTRYPOINT="$ENTRYPOINT"
EOF
    cat $BASH_COMPL_SCRIPT
}

build() {
    local pkg="$1"
    log-run "nix build -f $ENTRYPOINT $pkg"

    if [ $? -eq 0 ]; then
        echo ""
        log "Your build result is symlinked in ./result"
    fi
}

install() {
    local pkg="$1"
    log-run "nix-env -f $ENTRYPOINT -iA $pkg"
}

uninstall() {
    local pkg="$1"
    log-run "nix-env -e $pkg"
}

shell() {
    local pkg="$1"
    log-run "nix-shell $ENTRYPOINT -A $pkg"
}

update() {
    log "Updating toolbox ..."
    pushd $DIR 2>&1 >/dev/null
    if [[ ! $(git branch --show-current) == "master" ]]; then
      log-error "I am not on the master branch. Aborting"
      exit 1
    fi
    log-run "git fetch origin"
    if [[ $(git rev-parse origin/master) == $(git rev-parse HEAD) ]]; then
      log "Already up-to-date!"
      exit 0;
    fi
    log-run "git pull origin master"
    log-run "nix-env -f $ENTRYPOINT -u -b"
    popd
}

init() {
    log "Initializing setup ..."

    if _isNixInstalled ; then
        log "Looks like nix is already installed"
    else
        log "Looks like nix is not installed yet"
        log "Running 'curl https://nixos.org/nix/install | sh'"
        curl "$NIX_INSTALL_URL" | sh
        _sourceNix
    fi

    if _isSubstituterConfigured; then
        log "cache is already configured"
    else
        log "adding toolbox binary cache"
        _addCacheConfig
    fi

}

doctor() {
    OK="\e[32mOK\e[0m"
    X="\e[31mX\e[0m"
    FAIL=""

    log "Running sanity checks:\n"

    if _isNixInstalled
    then
        echo -e "- Nix installed :  $OK"
    else
        echo -e "- Nix installed :  $X"
        FAIL="."
    fi

    if _isSubstituterConfigured
    then
        echo -e "- toolbox binary cache: $OK"
    else
        echo -e "- toolbox binary cache: $X"
        FAIL="."
    fi

    if [[ $FAIL = "" ]]; then
        echo -e "\nAll essential tests passed."
    else
        echo -e "\nSome tests failed. Try running the init command:\n"
        echo -e "  ./toolbox init\n"
        echo -e "Check the 'Manual Configuration' section of the README.md if you continue to experience problems."
        exit 1
    fi
}

list() {
    paste -d' ' <(echo -e $(nix-instantiate $DIR/lib.nix -A list --eval --strict | tr -d "\"") | column -t -R 2) <(nix-env -f $ENTRYPOINT -q -a -c --no-name --description) | grep --color -E '^|>|<'
}

usage() {
cat <<EOM
Usage: toolbox <command> [args]

 init                 -- configure initial setup
 doctor               -- perform sanity checks
 list                 -- list available tools
 update               -- update all installed tools
 install [tool]       -- install a tool
 uninstall [tool]     -- uninstall a previously installed tool
 build [tool]         -- build a tool
 completions          -- output completion script

In order to enable context-sensitive completions (bash only!) run:

  $ source <(./toolbox completions)

You should add this to your init scripts.
EOM
}

if ! _isRegularUser; then
    log-error "root user detected. Run ./toolbox as non-root user!"
    exit 1
fi

if [ -z "$1" ]; then
    usage
    exit 1
fi

_sourceNix

subcommand="$1"
shift

case "$subcommand" in
    build)
        check_args $# 1 "build"
        build "$@"
        ;;
    install)
        check_args $# 1 "install"
        install "$@"
        ;;
    uninstall)
        check_args $# 1 "uninstall"
        uninstall $(_get_name "$@")
        ;;
    shell)
        check_args $# 1 "shell"
        shell "$@"
        ;;
    init)
        init "$@"
        ;;
    list)
        list "$@"
        ;;
    update)
        update "$@"
        ;;
    doctor)
        doctor
        ;;
    completions)
        register-completions
        ;;
    *)
        echo "Error: unknown command: $subcommand"
        usage
        exit 1
esac
