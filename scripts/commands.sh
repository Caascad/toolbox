#!/usr/bin/env bash

set -eu
set -o pipefail

DIR=$1
shift
COMMAND=$1
shift

ENTRYPOINT=$DIR/default.nix
source $DIR/scripts/utils.sh

list() {
    paste -d' ' <(echo -e $(nix-instantiate "$DIR/lib.nix" -A list --eval --strict | tr -d "\"") | column -t -R 2) <(nix-env -f "$ENTRYPOINT" -q -a -c --no-name --description) | grep --color -E '^|>|<'
}

install() {
    local pkgs="$*"
    log-run "nix-env -f $ENTRYPOINT -iA $pkgs"
}

uninstall() {
    local pkgs="$*"
    log-run "nix-env -e $pkgs"
}

update() {
    log "Updating toolbox ..."
    pushd "$DIR" >/dev/null 2>&1
    if [[ ! $(git rev-parse --abbrev-ref HEAD) == "master" ]]; then
      log-error "I am not on the master branch. Aborting"
    fi
    log-run "git fetch origin"
    if [[ $(git rev-parse origin/master) == $(git rev-parse HEAD) ]]; then
      log "Already up-to-date!"
    else
      log-run "git pull origin master"
    fi
    log-run "nix-env -f $ENTRYPOINT -u -b"
    popd >/dev/null 2>&1
}

doctor() {
    OK="\e[32mOK\e[0m"
    X="\e[31mX\e[0m"
    FAIL=""

    log "Running sanity checks:\n"

    if _isNixInstalled
    then
        echo -e "- Nix installed : $OK"
    else
        echo -e "- Nix installed : $X"
        FAIL="."
    fi

    if _isSubstituterConfigured
    then
        echo -e "- toolbox binary cache : $OK"
    else
        echo -e "- toolbox binary cache : $X"
        FAIL="."
    fi

    if _isChannelInstalled
    then
        echo -e "- toolbox channel : $OK"
    else
        echo -e "- toolbox channel : $X"
        FAIL="."
    fi

    if [[ $FAIL = "" ]]; then
        echo -e "\nAll essential tests passed."
    else
        echo -e "\nSome tests failed. Try running the init command:\n"
        echo -e "  ./toolbox init\n"
        echo -e "Check the 'Manual Configuration' section of the README.md if you continue to experience problems."
        exit 1
    fi
}

make-shell() {
    log "Creating shell ..."
    _generateToolboxJSON $(_lastCommit)

    log "Writing shell.nix file"
    cat <<EOF > shell.nix
# Generated by: toolbox make-shell ${@}
let
  pkgs = import <nixpkgs> {};
  toolboxSrc = builtins.fromJSON (builtins.readFile ./toolbox.json);
  toolbox = import (pkgs.fetchFromGitHub {
    owner = "$REPO_OWNER";
    repo = "$REPO_NAME";
    rev = toolboxSrc.commit;
    sha256 = toolboxSrc.sha256;
  }) {};
in
  pkgs.runCommand "deps" {
    buildInputs = with toolbox; [
      ${@}
    ];
  } ""
EOF
    # Evaluate shell.nix to check that all requested attributes are valid
    result=$(nix-instantiate shell.nix 2>&1 || true)
    # If not, parse error message to show the culprit
    if echo "$result" | grep -q error; then
        log-error "Error: '$(echo "$result" | sed "s/error: undefined variable '\([^']*\)'.*/\1/")' is not available in the toolbox"
    fi

    log "To activate the development shell:"
    log " - add 'use_nix' in an .envrc file to load tools with direnv"
    log " - or run 'nix-shell' to spawn a new shell with the tools"
    log "Don't forget to commit shell.nix and toolbox.json in your project."
}

update-shell() {
    if [ -f shell.nix ] && [ ! -f toolbox.json ]; then
        log-warning "Shells are now created with a different method."
        log-warning "You need to use the 'make-shell' command to recreate your shell."
        log-warning "After that you will be able to use 'update-shell'."
        exit 1
    fi
    if [ ! -f shell.nix ]; then
        log-error "I don't see any 'shell.nix' in this directory, aborting."
    fi
    log "Updating shell ..."
    commit=${1:-$(_lastCommit)}
    _generateToolboxJSON $commit
}

case "$COMMAND" in
    list)
        list
        ;;
    install)
        check_args_gt $# 1 "install"
        install "$@"
        ;;
    uninstall)
        check_args_gt $# 1 "uninstall"
        uninstall "$@"
        ;;
    update)
        update
        ;;
    make-shell)
        check_args_gt $# 1 "make-shell"
        make-shell "$@"
        ;;
    update-shell)
        check_args_le $# 1 "update-shell"
        update-shell "$@"
        ;;
    doctor)
        doctor
        ;;
    *)
        echo "Error: unknown command: $COMMAND"
        usage
        exit 1
esac
